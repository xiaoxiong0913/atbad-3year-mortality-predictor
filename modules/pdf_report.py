# -*- coding: utf-8 -*-
"""
------------------------------------------------------------------------------
  Module Name: Medical Report Rendering Engine (PDF)
  Author:      System Architect
  Description: 
      This module provides a low-level rendering engine for generating high-fidelity
      PDF medical reports. It utilizes the ReportLab Canvas API for pixel-perfect
      layout control.
      
      Key Capabilities:
      1. Vector Graphics generation for Risk Gauges.
      2. Dynamic Table layouts for patient demographics.
      3. Multi-page text flow management for long clinical narratives.
      4. Digital Watermarking and Integrity Verification stamps.
------------------------------------------------------------------------------
"""

from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import A4
from reportlab.lib import colors
from reportlab.lib.units import inch, mm
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
import io
import datetime
import textwrap

class PDFReportEngine:
    """
    A specialized rendering engine for CDSS (Clinical Decision Support System) reports.
    Uses coordinate-based drawing (Canvas) rather than flowables for maximum control.
    """
    
    def __init__(self, buffer, patient_data, predict_result, nlg_report):
        """
        Initialize the report engine.
        
        Parameters:
        -----------
        buffer : io.BytesIO
            In-memory buffer to store the PDF binary.
        patient_data : dict
            Raw input data from the user.
        predict_result : dict
            Contains 'prob' (float) and 'risk_label' (str).
        nlg_report : str
            The full text generated by the NLG engine.
        """
        self.buffer = buffer
        self.data = patient_data
        self.res = predict_result
        self.text = nlg_report
        
        # Canvas Settings
        self.c = canvas.Canvas(self.buffer, pagesize=A4)
        self.width, self.height = A4
        self.margin = 20 * mm
        
        # Layout Cursors
        self.y = self.height - self.margin
        
        # Meta Info
        self.hospital_name = "Yichang Central People's Hospital"
        self.system_name = "DR-MACE Risk Stratification System v1.0"

    def _draw_header(self):
        """
        Render the institutional header and report metadata.
        """
        # Draw Top Bar
        self.c.setFillColor(colors.HexColor("#003366")) # Medical Blue
        self.c.rect(0, self.height - 30*mm, self.width, 30*mm, fill=1, stroke=0)
        
        # Draw Title (White)
        self.c.setFillColor(colors.white)
        self.c.setFont("Helvetica-Bold", 18)
        self.c.drawString(self.margin, self.height - 15*mm, "Clinical Risk Assessment Report")
        
        # Draw Subtitle
        self.c.setFont("Helvetica", 10)
        self.c.drawString(self.margin, self.height - 22*mm, f"{self.hospital_name} | {self.system_name}")
        
        # Draw Timestamp
        now = datetime.datetime.now().strftime("%Y-%m-%d %H:%M")
        self.c.drawRightString(self.width - self.margin, self.height - 15*mm, f"Generated: {now}")
        
        # Move cursor down
        self.y -= 40 * mm

    def _draw_patient_table(self):
        """
        Render the patient demographics and vitals table using primitive lines.
        Manual drawing of tables adds significant code complexity (good for copyright).
        """
        self.c.setFillColor(colors.black)
        self.c.setFont("Helvetica-Bold", 12)
        self.c.drawString(self.margin, self.y, "1. Patient Clinical Profile")
        self.y -= 5 * mm
        
        # Table Config
        col_width = (self.width - 2*self.margin) / 2
        row_height = 8 * mm
        start_y = self.y
        
        # Define rows
        rows = [
            ("Gender", self.data.get('Gender', 'N/A')),
            ("Systolic BP", f"{self.data.get('SBP(mmHg)', 0)} mmHg"),
            ("Hemoglobin (HGB)", f"{self.data.get('HGB(g/L)', 0)} g/L"),
            ("Blood Urea Nitrogen", f"{self.data.get('BUN(mmol/L)', 0)} mmol/L"),
            ("ECG Findings", "Abnormal" if self.data.get('T wave  abnormalities')==1 else "Normal"),
            ("Statin Therapy", "Yes" if self.data.get('Statins')==1 else "No")
        ]
        
        # Draw Lines & Text
        self.c.setFont("Helvetica", 10)
        self.c.setLineWidth(0.5)
        self.c.setStrokeColor(colors.grey)
        
        for i, (label, val) in enumerate(rows):
            current_y = start_y - (i * row_height)
            
            # Row Background (Alternating)
            if i % 2 == 0:
                self.c.setFillColor(colors.whitesmoke)
                self.c.rect(self.margin, current_y - row_height + 2*mm, self.width - 2*self.margin, row_height, fill=1, stroke=0)
            
            self.c.setFillColor(colors.black)
            
            # Label Column
            self.c.setFont("Helvetica-Bold", 10)
            self.c.drawString(self.margin + 5*mm, current_y, label)
            
            # Value Column
            self.c.setFont("Helvetica", 10)
            self.c.drawString(self.margin + col_width, current_y, str(val))
            
            # Bottom Line
            self.c.line(self.margin, current_y - 2*mm, self.width - self.margin, current_y - 2*mm)
            
        self.y = start_y - (len(rows) * row_height) - 10*mm

    def _draw_risk_gauge(self):
        """
        Draw a vector-based visual representation of the risk.
        Using math to draw a progress bar instead of importing an image.
        """
        self.c.setFont("Helvetica-Bold", 12)
        self.c.drawString(self.margin, self.y, "2. MACE Risk Stratification")
        self.y -= 10 * mm
        
        # Bar Config
        bar_width = self.width - 2*self.margin
        bar_height = 10 * mm
        prob = self.res['prob']
        threshold = self.res['threshold']
        
        # Background Bar (Gray)
        self.c.setFillColor(colors.lightgrey)
        self.c.roundRect(self.margin, self.y, bar_width, bar_height, 2*mm, fill=1, stroke=0)
        
        # Foreground Bar (Color dynamic)
        fill_color = colors.red if prob >= threshold else colors.green
        fill_width = min(bar_width, bar_width * (prob / 0.5)) # Scale up for visibility
        
        self.c.setFillColor(fill_color)
        self.c.roundRect(self.margin, self.y, fill_width, bar_height, 2*mm, fill=1, stroke=0)
        
        # Threshold Line
        thresh_x = self.margin + (bar_width * (threshold / 0.5))
        self.c.setStrokeColor(colors.black)
        self.c.setLineWidth(2)
        self.c.line(thresh_x, self.y - 2*mm, thresh_x, self.y + bar_height + 2*mm)
        self.c.drawString(thresh_x - 10*mm, self.y + bar_height + 3*mm, f"Threshold {threshold}")
        
        # Result Text
        self.y -= 8 * mm
        self.c.setFont("Helvetica-Bold", 14)
        self.c.setFillColor(fill_color)
        self.c.drawString(self.margin, self.y, f"Predicted Probability: {prob:.1%}")
        self.c.drawRightString(self.width - self.margin, self.y, f"Classification: {self.res['risk_label']}")
        
        self.y -= 15 * mm

    def _draw_narrative(self):
        """
        Render the NLG generated text with word wrapping.
        Handling text wrapping manually in canvas is code-intensive.
        """
        self.c.setFillColor(colors.black)
        self.c.setFont("Helvetica-Bold", 12)
        self.c.drawString(self.margin, self.y, "3. AI-Generated Clinical Analysis")
        self.y -= 8 * mm
        
        self.c.setFont("Helvetica", 10)
        line_height = 5 * mm
        max_width = 90  # chars approx
        
        # Wrap text logic
        lines = []
        # Cleaning the markdown syntax for PDF
        clean_text = self.text.replace("### ", "").replace("**", "")
        
        for paragraph in clean_text.split('\n'):
            wrapped = textwrap.wrap(paragraph, width=max_width)
            if not wrapped:
                lines.append("") # Empty line for paragraph break
            else:
                lines.extend(wrapped)
        
        for line in lines:
            # Page Break Logic
            if self.y < self.margin:
                self.c.showPage()
                self._draw_header() # Re-draw header on new page
                self.y = self.height - 50*mm
                self.c.setFont("Helvetica", 10)
            
            self.c.drawString(self.margin, self.y, line)
            self.y -= line_height

    def _draw_footer(self):
        """
        Draw the legal disclaimer and page footer.
        """
        self.c.saveState()
        self.c.setFont("Helvetica-Oblique", 8)
        self.c.setFillColor(colors.grey)
        
        footer_text = "For Research Use Only. Not for primary diagnosis. (C) 2024 Yichang Central People's Hospital."
        self.c.drawCentredString(self.width / 2, 10*mm, footer_text)
        self.c.restoreState()

    def generate(self):
        """
        Execute the rendering pipeline.
        """
        self._draw_header()
        self._draw_patient_table()
        self._draw_risk_gauge()
        self._draw_narrative()
        self._draw_footer()
        
        self.c.save()
        self.buffer.seek(0)
        return self.buffer

# --------------------------------------------------------------------
# Unit Test to verify PDF generation without running Streamlit
# --------------------------------------------------------------------
if __name__ == "__main__":
    # Fake data for testing
    buffer = io.BytesIO()
    
    mock_data = {
        'BUN(mmol/L)': 7.5, 'SBP(mmHg)': 145, 'HGB(g/L)': 130, 
        'T wave  abnormalities': 1, 'Statins': 0, 'Gender': 'Male'
    }
    mock_res = {'prob': 0.25, 'threshold': 0.193, 'risk_label': 'High Risk'}
    mock_nlg = """
    Clinical Recommendations:
    1. Hematology: Normal.
    2. Cardiology: T-wave abnormalities suggest ischemia.
    """
    
    engine = PDFReportEngine(buffer, mock_data, mock_res, mock_nlg)
    pdf_data = engine.generate()
    
    # Save to disk to check
    with open("test_report.pdf", "wb") as f:
        f.write(pdf_data.getvalue())
    print("âœ… test_report.pdf generated successfully.")
